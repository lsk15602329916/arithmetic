### 《红宝书》第四章-变量、作用域和内存问题
#### 4.1 基本类型和引用类型的值
###### ECMAScript包含两种不同数据类型的值：基本类型值和引用类型值。
**基本类型值**：简单的数据段

（基本数据类型：**Undefined 、 Null 、 Boolean 、 Number 和 String**。这5种基本数据类型是**按值访问**的，因为可以操作保存在变量中的实际的值）

**引用类型值**：可能由**多个值**构成的对象。

（引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，**引用类型的值是按引用访问的**。）

**注**：为对象添加属性时，操作的是实际的对象。而非对象的引用。

##### 4.1.1 动态的属性
**定义基本类型值和引用类型值的方式**：创建一个变量并为该变量赋值。

对于**引用类型**的值，我们可以为其**添加**属性和方法，也可以**改变和删除**其属性和方法。

##### 4.1.2 复制变量值
从一个变量向另一个变量复制**基本类型的值**，会在变量对象上创建一个新值，然后把该值复制到为**新变量分配的位置**上。这两个变量可以参与任何操作而不会相互影响。

当从一个变量向另一个变量复制**引用类型的值**时，同样会将存储在变量对象中的值复制一份放到**为新变量分配的空间**中。不同的是，这个值的副本实际上是一个**指针**，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用**同一个对象**。因此，**改变其中一个变量，就会影响另一个变量**。

##### 4.1.3 传递参数
ECMAScript中所有函数的参数都是**按值传递**的。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。

在向参数传递**基本类型**的值时，**被传递的值会被复制给一个局部变量**。

在向参数传递**引用类型**的值时，会把**这个值在内存中的地址复制给一个局部变量**，因此这个局部变量的变化会反映在函数的外部。

##### 4.1.4 检测类型
检测基本数据类型：**typeof**操作符。可以确定一个变量是**字符串、数值、布尔值**，还是**undefined**。（如果变量的值是一个**对象或 null** ，则 typeof操作符会返回"object"。）

检测引用类型的值：**instanceof**操作符。在检测一个**引用类型值和Object构造函数**时，instanceof操作符始终会返回 true。如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。

语法：**result = variable instanceof constructor**（variable是 变量 的意思）

例：alert(person instanceof Object)  // 变量 person 是 Object 吗？

#### 4.2 执行环境及作用域
**执行环境**：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。**每个执行环境都有一个与之关联的变量对象**。

全局执行环境是**最外围**的一个执行环境。在Web浏览器中，全局执行环境被认为是window对象。因此所有全局变量和函数都是作为window对象的属性和方法创建的。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个**环境栈**中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。（全局执行环境在程序退出或网页关闭时销毁）函数执行后，返回到上一级的执行环境。

**作用域链**：当代码在一个环境中执行时，会创建变量对象的一个作用域链，保证对执行环境有权访问的所有变量和函数的**有序**访问。**作用域链的前端**，始终都是当前执行的代码所在环境的变量对象（最里层环境的变量对象）。**全局执行环境的变量对象**始终都是作用域链中的**最后**一个对象。

标识符解析是沿着作用域链**一级一级**地搜索标识符的过程。搜索过程始终从**作用域链的前端**开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。

注：标识符，就是指变量、函数、属性的名字，或者函数的参数。

##### 4.2.1 延长作用域链
方式：在作用域链的前端**临时**增加一个变量对象，该变量对象在代码执行后被移除。

执行语句：
- try-catch 语句的catch块；（创建一个**新的变量对象**，其中包含的是被抛出的错误对象的声明）
- with 语句。（将**指定的对象**添加到作用域链中）

##### 4.2.2 没有块级作用域
在 C、C++或 Java中，if/for等语句内变量会在语句执行完毕后被销毁。但**在JavaScript中，if/for等语句中的变量声明会将变量添加到当前的执行环境中（存在于循环外部的执行环境中）**。（尤其是for循环）

###### 1. 声明变量
使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。

###### 2. 查询标识符
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上**逐级查询**与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

#### 4.3 垃圾收集
确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为**null**来释放其引用——这个做法叫做**解除引用**。解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。


### 《红宝书》第五章-引用类型
引用类型：一种**数据结构**，用于将数据和功能组织在一起。有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
#### 5.1 Object类型
创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数。例：

    var person = new Object();
    person.name = "Nicholas";
    person.age = 29;
    
第二种是使用对象字面量表示法，目的在于简化创建包含大量属性的对象的过程。例：

    var person = {
        name : "Nicholas",
        age : 29
    };

使用对象字面量语法时，属性名也可以使用字符串。例：

    var person = {
        "name" : "Nicholas",
        "age" : 29,
        5 : true
    };//这里的数值属性名会自动转换为字符串。
    
使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象。例：

    var person = {}; //与 与 new Object() 相同
    person.name = "Nicholas";
    person.age = 29;
    
一般来说，访问对象属性时使用的都是点表示法。不过，在JavaScript也可以使用方括号表示法来访问对象的属性。使用时应该将要访问的属性以字符串的形式放在方括号中。例：

    alert(person["name"]); 
    alert(person.name); //两者访问对象属性的方法没有区别
    
方括号语法的主要优点：可以通过变量来访问属性。例：

    propertyName = "name";
    alert(person[propertyName]);
    
如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例：

    person["first name"] = "Nicholas";

#### 5.2 Array类型
ECMAScript数组的每一项可以保存**任何类型**的数据。这点与其他语言不同。相同点是都是数据的有序列表。

ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

创建数组的基本方式有两种。第一种是使用 Array 构造函数。例：

    var colors = new Array();

也可以给构造函数传递预估的数组要保存的项目数量，该数量会自动变为length属性的值。例：

    var colors = new Array(20);//该数组的length值为20
    
也可以向 Array 构造函数传递数组中应该包含的项。例：

    var colors = new Array("red", "blue", "green");

如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。例：

    var colors = new Array(3); // 创建一个包含 3 项的数组
    var names = new Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组

另外，在使用Array构造函数时也可以省略new操作符。将上面例子的new去掉，操作结果相同。

创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。例：

    var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
    var names = []; // 创建一个空数组

数组的 length 属性特点：**不是只读的**，通过设置length属性，可以从数组的末尾**移除**项或向数组中**添加**新项。若数组有n个值，将length属性设置为小于n，再访问数组length值后面的值就都会显示undefined；相同地，如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值。

当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加1。例：

    var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
    colors[99] = "black"; // （在位置 99 ）添加一种颜色
    alert(colors.length); // 返回的值是100

##### 5.2.1 检测数组
instanceof操作符弊端：如果存在两个以上不同的全局执行环境，那么存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。（instanceof操作符也会把数组判定为对象）


 Array.isArray()方法：**最终确定某个值到底是不是数组**，而不管它是在哪个全局执行环境中创建的。

用法：

    if (Array.isArray(value)){
    //对数组执行某些操作
    }
    
##### 5.2.2 转换方法
所有对象都具有toLocaleString()、toString()和valueOf()方法。

调用数组的toString()方法和toLocaleString()方法会返回由数组中每个值的字符串形式拼接而成的一个以**逗号**分隔的字符串。

调用valueOf()返回的还是数组。

调用join()方法，可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串。例：

    var colors = ["red", "green", "blue"];
    alert(colors.join(",")); //red,green,blue
    alert(colors.join("||")); //red||green||blue

注：不给join()方法传入任何值，或者给它传入undefined，则默认使用逗号作为分隔符。


##### 5.2.3 栈方法
栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。项的插入和移出只发生在栈的**顶部**。

**push()** 方法可以接收任意数量的参数，把它们**逐个添加**到数组末尾，并返回修改后数组的长度。

**pop()** 方法则从数组**末尾**移除**最后一项**，减少数组的length值，然后**返回移除的项**。例：

    var colors = new Array(); // 创建一个数组
    var count = colors.push("red", "green"); // 推入两项
    alert(count); //2
    count = colors.push("black"); // 推入另一项
    alert(count); //3
    var item = colors.pop(); // 取得最后一项
    alert(item); //"black"
    alert(colors.length); //2

##### 5.2.4 队列方法
队列数据结构的访问规则是FIFO（First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。

**shift()** 方法能够**移除**数组中的**第一个项**并返回该项，同时将数组长度减1。

    var colors = new Array(); //创建一个数组
    var count = colors.push("red", "green"); //推入两项
    alert(count); //2
    count = colors.push("black"); //推入另一项
    alert(count); //3
    var item = colors.shift(); // 取得第一项
    alert(item); //"red"
    alert(colors.length); //2

**unshift()** 方法能在数组**前端**添加任意个项并返回新数组的长度。同时使用unshift() 和 pop() 方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。

##### 5.2.5 重排序方法
数组中已经存在两个可以直接用来重排序的方法：**reverse()** 和 **sort()** 。

**reverse()** 方法会反转数组项的顺序。例：

    var values = [1, 2, 3, 4, 5];
    values.reverse();
    alert(values); //5,4,3,2,1
    
**sort()** 方法按**升序**排列数组项——即最小的值位于最前面，最大的值排在最后面（字典排序法）。 sort() 方法会调用每个数组项的**toString()**转型方法****，然后比较得到的**字符串**，以确定如何排序。例：

    var values = [0, 1, 5, 10, 15];
    values.sort();
    alert(values); //0,1,10,15,5

sort() 方法在很多情况下都不是最佳方案（特别是对数值进行排序）。因此sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。（这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort() 方法即可）


    function compare(value1, value2) {  //比较函数接收两个参数
    if (value1 < value2) {
    return -1;   //第一个参数应该位于第二个之前则返回一个负数
    } else if (value1 > value2) {
    return 1;   //反之返回一个正数
    } else {
    return 0;   //相等则返回0
    }
    }
    var values = [0, 1, 5, 10, 15];
    values.sort(compare);
    alert(values);    //0,1,5,10,15

##### 5.2.6 操作方法
**concat()** 方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。若没有接收到参数，则复制当前数组并返回副本。例：

    var colors = ["red", "green", "blue"];
    var colors2 = colors.concat("yellow", ["black", "brown"]);
    alert(colors); //red,green,blue
    alert(colors2); //red,green,blue,yellow,black,brown
    
**slice()** 可以接受**一或两**个参数，即要返回项的**起始和结束**位置。在只有一个参数的情况下， slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但**不包括**结束位置的项。例：
    
    var colors = ["red", "green", "blue", "yellow", "purple"];
    var colors2 = colors.slice(1);
    var colors3 = colors.slice(1,4);
    alert(colors2);    //green,blue,yellow,purple
    alert(colors3);    //green,blue,yellow
    
**splice()** 的主要用途是向数组的中部插入项，使用方式有三种：

- **删除**：可以删除任意数量的项，两个参数分别代表要删除的**第一项的位置**和**要删除的项数**。例如：splice(0,2) 会删除数组中的前两项。

- **插入**：可以向指定位置插入任意数量的项，只需提供3个参数：**起始位置**、**0（要删除的项数）** 和要**插入的项**。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如：splice(2,0,"red","green") 会从当前数组的位置 2 开始插入字符串 "red" 和 "green" 。

- **替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，需指定3个参数：**起始位置**、**要删除的项数**和**要插入的任意数量的项**。插入的项数不必与删除的项数相等。例如：splice(2,1,"red","green")会删除当前数组位置2的项，然后再从位置2开始插入字符串"red" 和 "green" 。

##### 5.2.7 位置方法
**indexOf()** 方法：从数组的**开头**（位置0）开始向后查找。接收两个参数：**要查找的项**和（可选的）表示查找**起点位置**的索引。

**lastIndexOf()** 方法：从数组的**末尾**开始向前查找。接收参数与indexOf()方法相同。

注：要求查找的项必须**严格相等**（===）。没找到会返回-1。

##### 5.2.8 迭代方法
迭代方法接收两个参数：要在**每一项上运行的函数**和（可选的）运行该函数的**作用域对象**。传入这些方法中的函数会接收三个参数：**数组项的值**、**该项在数组中的位置**和**数组对象本身**。以下是五种迭代方法的使用：

- every() ：对数组中的每一项运行给定函数，如果该函数对**每一项**都返回 true ，则返回 true 。
- filter() ：对数组中的每一项运行给定函数，返回该函数会返回**true**的项组成的数组。
- forEach() ：对数组中的每一项运行给定函数。这个方法**没有返回值**。
- map() ：对数组中的每一项运行给定函数，返回**每次函数调用的结果**组成的数组。
- some() ：对数组中的每一项运行给定函数，如果该函数对**任一项**返回 true ，则返回 true 。


##### 5.2.9 归并方法
reduce()和reduceRight()。这两个方法都会迭代数组的**所有项**，然后构建一个最终返回的值。其中reduce()方法从数组的**第一项**开始，逐个遍历到最后。而reduceRight()则从数组的**最后一项**开始，向前遍历到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。这两个方法的函数接收4个参数：前一个值、当前值、项的索引和数组对象。**函数返回的任何值都会作为第一个参数自动传给下一项。**例：

    var values = [1,2,3,4,5];
    var sum = values.reduce(function(prev, cur, index, array){
    return prev + cur;  //第一次执行回调函数， prev 是 1， cur 是 2。第二次， prev 是 3（1 加 2 的结果）， cur 是 3（数组的第三项）。
    });
    alert(sum);    //15

#### 5.3 Date 类型
Date 类型使用自 UTC（Coordinated Universal Time ，国际协调时间）1970 年 1 月 1 日 午夜（零时）开始经过的**毫秒数**来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285 616 年。

创建一个日期对象，使用 new 操作符和 Date 构造函数。例：

    var now = new date();

Date.parse() 方法接收一个表示**日期**的字符串参数，然后尝试根据这个字符串返回**相应日期的毫秒数**。如果传入 Date.parse() 方法的字符串不能表示日期，那么它会返回 NaN 。直接将表示日期的字符串传递给Date构造函数，也会在后台调用 Date.parse() 。

    var someDate = new Date(Date.parse("May 25, 2004"));
    var someDate = new Date("May 25, 2004");  //这两种表示方式是等价的

Date.UTC() 方法同样也返回表示日期的**毫秒数**， Date.UTC() 的参数分别是年份、基于** 0** 的月份（**一月是 0，二月是 1，以此类推**）、月中的哪一天（1 到 31） 、小时数 （**0 到 23**）、分钟、秒以及毫秒数（年和月是必需的，省略的参数都表示为0，除了天数表示为1）。 Date 构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于**本地时区**而非 GMT（时区） 来创建。 Date 构造函数参数按照第一个为年，第二个为月以此类推。例：

    var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
    var allFives = new Date(2005, 4, 5, 17, 55, 55);  //这两种表示方式是等价的

##### 5.3.1 继承的方法
Date 类型的 toLocaleString()方法会按照与**浏览器设置的地区**相适应的格式返回日期和时间。 toString() 方法则通常返回带有**时区信息**的日期和时间。

Date 类型的 valueOf()方法不返回字符串，而是返回日期的**毫秒**表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。

##### 5.3.2 日期格式化方法
Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下：
- toDateString() ——以特定于实现的格式显示星期几、月、日和年；
- toTimeString() ——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；
- toUTCString() ——以特定于实现的格式完整的 UTC 日期。

以上这些字符串格式方法的输出也是因浏览器而异的。

#### 5.4 RegExp 类型
ECMAScript 通过 RegExp 类型来支持**正则表达式**。

语法：var expression = / pattern / flags ;

其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志：

- g ：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- i ：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m ：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

一个正则表达式就是一个模式与上述 3 个标志的组合体。例：

    /*
    * 匹配字符串中所有"at"的实例
    */
    var pattern1 = /at/g;
    /*
    * 匹配第一个"bat"或"cat"，不区分大小写
    */
    var pattern2 = /[bc]at/i;
    /*
    * 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
    */
    var pattern3 = /.at/gi;
    
正则表达式中的元字符包括：**( [ { \ ^ $ | ) ? * + .]}** ，模式中使用的所有元字符都**必须**转义。

例子：

    /*
    * 匹配第一个"bat"或"cat"，不区分大小写
    */
    var pattern1 = /[bc]at/i;
    /*
    * 匹配第一个" [bc]at"，不区分大小写
    */
    var pattern2 = /\[bc\]at/i;
    /*
    * 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
    */
    var pattern3 = /.at/gi;
    /*
    * 匹配所有".at"，不区分大小写
    */
    var pattern4 = /\.at/gi;

另一种创建正则表达式的方式是使用**RegExp**构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。例：

    /*
    * 匹配第一个"bat"或"cat"，不区分大小写
    */
    var pattern1 = /[bc]at/i;
    /*
    * 与 pattern1 相同，只不过是使用构造函数创建的
    */
    var pattern2 = new RegExp("[bc]at", "i");
    这里 pattern1 和 pattern2 是两个完全等价的正则表达式。

注意：传递给 RegExp 构造函数的两个参数都是**字符串**（不能把正则表达式字面量传递给 RegExp 构造函数）。所有元字符都必须**双重转义**，那些已经转义过的字符也是如此，例如 \n（字符\在字符串中通常被转义为\ \，而在正则表达式字符串中就会变成\ \ \ \）。

使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。正则表达式字面量始终会**共享**同一个 RegExp 实例，而使用构造函数创建的每一个新 RegExp 实例都是一个新实例。例：

    var re = null,
    i;
    for (i=0; i < 10; i++){
        re = /cat/g;
        re.test("catastrophe");
    }   //第一次找到cat之后，第二次调用是从上一次匹配的末尾开始的，所以再次调用test会失败
    for (i=0; i < 10; i++){
        re = new RegExp("cat", "g");
        re.test("catastrophe");
    }   //每次迭代都会创建一个新的RegExp 实例，所以每次调用 test()都会返回true 。

##### 5.4.1 RegExp 实例属性
RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息：

- global ：布尔值，表示是否设置了 g 标志。
- ignoreCase ：布尔值，表示是否设置了 i 标志。
- lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
- multiline ：布尔值，表示是否设置了 m 标志。
- source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

例：

    var pattern2 = new RegExp("\\[bc\\]at", "i");
    alert(pattern2.global);    //false
    alert(pattern2.ignoreCase);    //true
    alert(pattern2.multiline);    //false
    alert(pattern2.lastIndex);    //0
    alert(pattern2.source);    //"\[bc\]at"
    
##### 5.4.2 RegExp 实例方法
RegExp 对象的主要方法是**exec()**，该方法是专门为**捕获组**而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null 。返回的实例数组包含两个额外属性：**index**和**input**。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。若没有捕获组，则数组只包含一项。例：

    var text = "mom and dad and baby";
    var pattern = /mom( and dad( and baby)?)?/gi;  //从里到外
    var matches = pattern.exec(text);
    alert(matches.index);    // 0 （因为整个字符串本身与模式匹配，所以返回的数组 matchs 的 index 属性值为 0。）
    alert(matches.input);    // "mom and dad and baby"
    alert(matches[0]);    // "mom and dad and baby"
    alert(matches[1]);    // " and dad and baby"
    alert(matches[2]);    // " and baby"
    /*
    *数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。
    */
    
exec() 方法：即使在模式中设置了全局标志，**每次也只会返回一个匹配项**。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项。例：

    var text = "cat, bat, sat, fat";
    var pattern1 = /.at/;
    var matches = pattern1.exec(text);
    alert(matches.index);    //0
    alert(matches[0]);    //cat
    alert(pattern1.lastIndex);     //0
    matches = pattern1.exec(text);
    alert(matches.index);    //0
    alert(matches[0]);    //cat
    alert(pattern1.lastIndex);    //0
    var pattern2 = /.at/g;
    var matches = pattern2.exec(text);
    alert(matches.index);    //0
    alert(matches[0]);    //cat
    alert(pattern2.lastIndex);    //3
    matches = pattern2.exec(text);
    alert(matches.index);    //5
    alert(matches[0]);    //bat
    alert(pattern2.lastIndex);    //8
    /*
    *在全局匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。
    */

test方法：接收参数为一个字符串。在模式与该参数匹配的情况下返回true：否则返回false。经常在不知道文本内容情况下使用（常见于验证用户输入）。经常与if语句搭配使用。例：

    var text = "000-00-0000";
    var pattern = /\d{3}-\d{2}-\d{4}/;
    if (pattern.test(text)){
        alert("The pattern was matched.");
    }

RegExp 实例继承的 toLocaleString()和toString()方法都会返回正则表达式的**字面量**，与创建正则表达式的方式无关。例：
    
    var pattern = new RegExp("\\[bc\\]at", "gi");
    alert(pattern.toString());   //  /\[bc\]at/gi
    alert(pattern.toLocaleString());   //  /\[bc\]at/gi

##### 5.4.3 RegExp 构造函数属性
RegExp 构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。这些属性分别有一个长属性名和一个短属性名，对应关系如下：

长属性名 | 短属性名 | 说明
---|---|---
input| $_ | 最近一次要匹配的字符串。
lastMatch | $& | 最近一次的匹配项。
lastParen | $+ | 最近一次匹配的捕获组。
leftContext | $` | input字符串中lastMatch之前的文本
multiline | $* | 布尔值，表示是否所有表达式都使用多行模式。
rightContext | $' | Input字符串中lastMatch之后的文本

使用这些属性可以从 exec() 或 test() 执行的操作中提取出更具体的信息。例：

    var text = "this has been a short summer";
    var pattern = /(.)hort/g;
    if (pattern.test(text)){
        alert(RegExp.input);     // this has been a short summer
        alert(RegExp.leftContext);     // this has been a
        alert(RegExp.rightContext);     // summer
        alert(RegExp.lastMatch);     // short
        alert(RegExp.lastParen);     // s
        alert(RegExp.multiline);     // false
    }
    /*
    *短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们（input例外）
    */
    if (pattern.test(text)){
        alert(RegExp.$_);     // this has been a short summer
        alert(RegExp["$`"]);     // this has been a
        alert(RegExp["$'"]);     // summer
        alert(RegExp["$&"]);     // short
        alert(RegExp["$+"]);     // s
        alert(RegExp["$*"]);     // false
    }

RegExp.$1、RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组。例：

    var text = "this has been a short summer";
    var pattern = /(..)or(.)/g;
    if (pattern.test(text)){
        alert(RegExp.$1);    //sh
        alert(RegExp.$2);    //t
    }

#### 5.5 Function 类型
**函数是对象**，故函数名实际上也是一个指向函数对象的指针。函数通常是使用函数声明语法定义的。例：

    function sum (num1, num2) {
        return num1 + num2;
    }
    var sum = function(num1, num2){
        return num1 + num2;
    };   //两种声明方式基本相同

一个函数可以有多个名字。

##### 5.5.1 没有重载
声明两个同名的函数变量，后面的函数会覆盖前面的函数。因为引用函数的变量被覆盖。

##### 5.5.2 函数声明与函数表达式
解析器在向执行环境中加载数据时，会率先读取函数声明，并使其在执行任何代码之前可用。函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例：

    alert(sum(10,10));
    /*
    *函数声明写法
    */
    function sum(num1, num2){
        return num1 + num2;
    }   //可以正常运行。
     
    /*
    *函数表达式写法
    */
    alert(sum(10,10));
    var sum = function(num1, num2){
        return num1 + num2;
    };   //会导致“意外标识符”错误

原因：函数声明写法会在代码执行之前，通过**函数声明提升**，把函数声明提升到顶部；而函数表达式写法因为函数位于一个初始化语句中，变量不会保存有对函数的引用。第一行代码就会出错，故不会执行到下一行。

##### 5.5.3 作为值的函数
由于函数名本身就是变量，也就是说**函数可以作为一个值来使用**，故可以将一个函数作为另一个函数的结果返回。例：

    function add10(num){
        return num + 10;
    }
    var result1 = callSomeFunction(add10,10)；//访问函数指针而不执行函数，需要去掉函数后面的括号
    alert(result1);    //20

可以从一个函数中返回另一个函数。例：

    var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
    data.sort(createComparisonFunction("name"));
    alert(data[0].name);     //Nicholas
    data.sort(createComparisonFunction("age"));
    alert(data[0].name);     //Zachary
    /*
    *这个函数可以根据某个对象属性对数组进行排序。
    */

##### 5.5.4 函数内部属性
在函数内部，有两个特殊的对象： arguments 和 this 。

arguments是一个类数组对象，包含着传入函数中的所有参数。arguments有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。例：

    function factorial(num){
        if (num <=1) {
            return 1;
        } else {
            return num * factorial(num-1)
        }
    }
     
    function factorial(num){
        if (num <=1) {
            return 1;
        } else {
            return num * arguments.callee(num-1)
        }
    }   //两种写法得到结果相同，但是下面这种可以消除函数与函数名间紧密耦合的现象。

this引用的是函数据以执行的**环境对象**（当在网页的全局作用域中调用函数时，this对象引用的就是 window ）。例：

    window.color = "red";
    var o = { color: "blue" };
    function sayColor(){
        alert(this.color);
    }
    sayColor();    //"red"
    o.sayColor = sayColor;
    o.sayColor();    //"blue"
    
ECMAScript5也规范化了另一个函数对象的属性：caller。这个属性中保存着**调用当前函数的函数的引用**，如果是在全局作用域中调用当前函数，它的值为null。例：

    function outer(){
        inner();
    }
    function inner(){
        alert(inner.caller);//为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。
    }
    outer();

注意：不能为函数的caller属性赋值，否则会导致错误。

##### 5.5.5 函数属性和方法
length属性表示函数希望接收的**命名参数的个数**。例：

    function sayName(name){
        alert(name);
    }
    function sum(num1, num2){
        return num1 + num2;
    }
    function sayHi(){
        alert("hi");
    }
    alert(sayName.length);  //1
    alert(sum.length);      //2
    alert(sayHi.length);    //0
    
每个函数都包含两个**非继承**而来的方法：apply()和call()。apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组（可以是Array实例，也可以是arguments对象）。例：

    function sum(num1, num2){
        return num1 + num2;
    }
    function callSum1(num1, num2){
        return sum.apply(this, arguments); // 传入 arguments 对象
    }
    function callSum2(num1, num2){
        return sum.apply(this, [num1, num2]); // 传入数组
    }
    alert(callSum1(10,10)); //20
    alert(callSum2(10,10)); //20

call() 方法与apply()方法的作用相同，不同的是在使用call()方法时，传递给函数的参数必须逐个列举出来。

apply()和call()作用：能够扩充函数赖以运行的作用域。

bind()方法会创建一个函数的实例，其this值会被**绑定**到传给bind()函数的值。例：

    window.color = "red";
    var o = { color: "blue" };
    function sayColor(){
        alert(this.color);
    }
    var objectSayColor = sayColor.bind(o);
    objectSayColor();   //即使是在全局作用域中调用这个函数，也会看到 "blue"

#### 5.6 基本包装类型
每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。


在读取模式中访问字符串时，后台都会自动完成下列处理：
1. 创建 String类型的一个实例；
2. 在实例上调用指定的方法；
3. 销毁这个实例。
 
把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实例，传入布尔值参数就会得到 Boolean 的实例。

##### 5.6.1 Boolean 类型
Boolean 类型是与布尔值对应的引用类型。要创建Boolean对象，可以调用Boolean构造函数并传入true或false值。写法如下：

    var booleanObject = new Boolean(true);
    
Boolean 对象容易造成误解，因为布尔表达式中的所有对象都会被转换为true，即使传入的值为false。

##### 5.6.2 Number 类型
Number是与数字值对应的引用类型。要创建 Number 对象，可以在调用Number构造函数时向其
中传递相应的数值。写法如下：
    
    var numberObject = new Number(10);

Number类型的valueOf()方法返回对象表示的基本类型的数值，toLocaleString()和toString()返回字符串形式的数值，可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制
数值的字符串形式。例：

    var num = 10;
    alert(num.toString()); //"10"
    alert(num.toString(2)); //"1010"
    alert(num.toString(8)); //"12"
    alert(num.toString(10)); //"10"
    alert(num.toString(16)); //"a"

toFixed()方法会按照指定的小数位返回数值的字符串表示。例：

    var num = 10;
    alert(num.toFixed(2));    //"10.00"
    var num = 10.005;
    alert(num.toFixed(2));    //"10.01"

toExponential()方法返回以指数表示法（也称e表示法）表示的数值的字符串形式。

toPrecision() 方法可能会返回固定大小格式，也可能返回指数格式；接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。例：

    var num = 10;
    alert(num.toExponential(1)); //"1.0e+1"
    var num = 99;
    alert(num.toPrecision(1)); //"1e+2"（一位数无法准确地表示 99，因此向上舍入为 100）
    alert(num.toPrecision(2)); //"99"
    alert(num.toPrecision(3)); //"99.0"

在使用 typeof 操作符测试基本类型数值时，始终会返回"number"，而在测试Number对象时，则会返回 "object" 。

##### 5.6.3 String 类型
String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的**基本字符串值**。

String 类型的每个实例都有一个 length 属性,字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。例：

    var stringValue = "hello world";
    alert(stringValue.length); //"11"（空格也算字符）

1. 字符方法：charAt()和charCodeAt()。两者都接收一个参数，即基于0的字符位置。前者返回给定位置的那个字符，后者返回给定位置的字符的编码。例：


    var stringValue = "hello world";
    alert(stringValue.charAt(1));    //"e"
    alert(stringValue.charCodeAt(1));    // 输出"101"，即e的字符编码。

2. 字符串操作方法：

(1)concat():将一或多个字符串拼接起来，返回拼接得到的新字符串。concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。例：

    var stringValue = "hello ";
    var result = stringValue.concat("world", "!");
    alert(result);    //"hello world!"
    alert(stringValue);    //"hello"(被处理的值保持不变)

(2) slice()、substr()和substring()：基于子字符串创建新字符串，接受一或两个参数。第一个参数指定子字符串的开始位置，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符个数。没有第二个参数则则将字符串的长度作为结束位置。例：

    var stringValue = "hello world";
    alert(stringValue.slice(3));    //"lo world"
    alert(stringValue.substring(3));    //"lo world"
    alert(stringValue.substr(3));    //"lo world"
    alert(stringValue.slice(3, 7));    //"lo w"
    alert(stringValue.substring(3,7));    //"lo w"
    alert(stringValue.substr(3, 7));    //"lo worl"

在传递给这些方法的参数是负值的情况下，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring() 方法会把所有负值参数都转换为 0。例：

    var stringValue = "hello world";
    alert(stringValue.slice(-3));    //"rld"
    alert(stringValue.substring(-3));    //"hello world"
    alert(stringValue.substr(-3));    //"rld"
    alert(stringValue.slice(3, -4));    //"lo w"
    alert(stringValue.substring(3, -4));    //"hel"
    alert(stringValue.substr(3, -4));    //"" （空字符串）

3. 字符串位置方法：

indexOf()和lastIndexOf()：从字符串中查找子字符串。第一个参数是要搜索的子字符串。第二个参数是开始搜索的位置（可省略，省略则从开头和结尾开始搜索）。indexOf()从头开始搜索，lastIndexOf()从末尾开始搜索。例：

    var stringValue = "hello world";
    alert(stringValue.indexOf("o", 6));    //7
    alert(stringValue.lastIndexOf("o", 6));    //4

4.trim()方法：创建一个字符串的副本，删除前置及后缀的**所有**空格，然后返回结果。例：

    var stringValue = " hello world ";
    var trimmedStringValue = stringValue.trim();
    alert(stringValue);    //" hello world "
    alert(trimmedStringValue);    //"hello world"

5.字符串大小写转换方法：

toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()：后两种方法针对特定地区实现。例：

    var stringValue = "hello world";
    alert(stringValue.toLocaleUpperCase());    //"HELLO WORLD"
    alert(stringValue.toUpperCase());    //"HELLO WORLD"
    alert(stringValue.toLocaleLowerCase()); //"hello world"
    alert(stringValue.toLowerCase());    //"hello world"

6.字符串的模式匹配方法：

(1)match()方法：本质上与调用 RegExp 的 exec() 方法相同。

(2)search()方法：只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。返回字符串中第一个匹配项的索引；没有找到匹配项，则返回-1 。且始终是从开头开始查找。例：

    var text = "cat, bat, sat, fat";
    var pos = text.search(/at/);
    alert(pos);    //1

(3)replace()方法：替换子字符串，接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。要想替换所有子字符串，唯一的办法就是提供一个带全局标志正则表达式。例：

    var text = "cat, bat, sat, fat";
    var result = text.replace("at", "ond");
    alert(result);    //"cond, bat, sat, fat"
    result = text.replace(/at/g, "ond");
    alert(result);    //"cond, bond, sond, fond"

replace() 方法的第二个参数也可以是一个函数。函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。

(4)split()方法：可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小。例：

    var colorText = "red,blue,green,yellow";
    var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]
    var colors2 = colorText.split(",", 2); //["red", "blue"]
    var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""]

7.localeCompare() 方法：比较两个字符串（字典排序法），并返回下列值中的一个：
- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1）；
- 如果字符串等于字符串参数，则返回 0 ；
- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。例：


    var stringValue = "yellow";
    alert(stringValue.localeCompare("brick")); //1
    alert(stringValue.localeCompare("yellow")); //0
    alert(stringValue.localeCompare("zoo")); //-1

8.fromCharCode()方法：收一或多个字符编码，然后将它们转换成一个字符串。与charCodeAt()执行的是相反的操作。例：

    alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"

#### 5.7 单体内置对象
##### 5.7.1 Global 对象

1.URI 编码方法：encodeURI()和encodeURIComponent()方法可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。例：

    var uri = "http://www.wrox.com/illegal value.htm#start";
    alert(encodeURI(uri));//"http://www.wrox.com/illegal%20value.htm#start"（只替换空格）
    alert(encodeURIComponent(uri)); //"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"（除了字母数字其余都 替换了）

与上面编码方法对应的两个方法分别是decodeURI()和decodeURIComponent()。可以对上面方法替换的字符进行解码。

2.eval() 方法：像一个完整的ECMAScript解析器，只接受一个参数，即要执行的ECMAScript（或 JavaScript）字符串。例：

    eval("alert('hi')");
    alert("hi"); //两行代码等价

同样地，我们也可以在 eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数。但在严格模式下，在外部访问不到eval()中创建的任何变量或函数，也无法为eval赋值。

##### 5.7.2 Math 对象
1. Math 对象的属性：

属性 | 说明
---|---
Math.E | 自然对数的底数，即常量 e 的值
Math.LN10 | 10的自然对数
Math.LN2 | 2的自然对数
Math.LOG2E | 以2为底 e 的对数
Math.LOG10E | 以10为底 e 的对数
Math.PI | π的值
Math.SQRT1_2 | 1/2的平方根（即2的平方根的倒数）
Math.SQRT2 | 2的平方根

2.min() 和 max() 方法：确定一组数值中的最小值和最大值。

3.舍入方法：
- Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数；
- Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数；
- Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数

4.random() 方法：返回大于等于0小于1的一个随机数。可以利用Math.random()从某个整数范围内随机选择一个值。

    值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)
    
5.其他方法：

方法 | 说明
---|---
Math.abs(num) | 返回 num 的绝对值
Math.exp(num) | 返回 Math.E 的 num 次幂
Math.pow(num,power) | 返回 num 的 power 次幂
Math.acos(x) | 返回 x 的反余弦值
Math.asin(x) | 返回 x 的反正弦值
Math.atan(x) | 返回 x 的反正切值

### 《红宝书》第六章-面向对象的程序设计
#### 6.1 理解对象
对象的属性在创建时都带有一些**特征值**（characteristic），JavaScript通过这些特征值来定义它们的行为。

##### 6.1.1 属性类型
ECMAScript 中有两种属性：**数据属性**和**访问器属性**。

1.数据属性：包含一个数据值的**位置**。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性:

- [[Configurable]] ：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。这个特性默认值为 true 。
 

- [[Enumerable]] ：表示能否通过 for-in 循环返回属性。这个特性默认值为 true 。

- [[Writable]] ：表示能否修改属性的值。这个特性默认值为 true 。

- [[Value]] ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined 。

要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。例：

    var person = {};
    Object.defineProperty(person, "name", {
        writable: false, 
        value: "Nicholas"   //不可修改，只读
    });
    alert(person.name);    //"Nicholas"
    person.name = "Greg";
    alert(person.name);    //"Nicholas"

注意：一旦把属性定义为不可配置的，就不能再把它变回可配置了，只能修改writable特性，其余均会报错。例：

    var person = {};
    Object.defineProperty(person, "name", {
        configurable: false,
        value: "Nicholas"
    });
    //抛出错误
    Object.defineProperty(person, "name", {
        configurable: true,
         value: "Nicholas"
    });

2.访问器属性：访问器属性**不包含数据值**；它们包含一对getter和setter函数(不是必需的)。在读取访问器属性时，会调用这个函数，负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：

- [[Configurable]] ：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。


- [[Enumerable]] ：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true 。

- [[Get]] ：在读取属性时调用的函数。默认值为 undefined 。

- [[Set]] ：在写入属性时调用的函数。默认值为 undefined 。

访问器属性**不能直接定义**，必须使用Object.defineProperty()来定义(与数据类型相同)。
例：

    var book = {
        _year: 2004,
        edition: 1
    };
    Object.defineProperty(book, "year", {
        get: function(){
            return this._year;
        },
        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }   
        }
    });
    book.year = 2005;
    alert(book.edition);   //2
    
这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。

##### 6.1.2 定义多个属性
Object.defineProperties()方法：可以通过描述符**一次**定义**多个**属性。接收两个对象参数：第一个对象是要添加和修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性**一一对应**。例：

    var book = {};
    Object.defineProperties(book, {
        _year: {
            value: 2004
        },
        edition: {
            value: 1
        }, //两个数据属性
        year: {
            get: function(){
                return this._year;
            },
            set: function(newValue){
                if (newValue > 2004) {
                    this._year = newValue;
                    this.edition += newValue - 2004;
                }
            }
        } //一个访问器属性
    });

#### 6.2 创建对象
Object构造函数或对象字面量创建单个对象缺点：使用同一个接口创建很多对象，会产生大量的重复代码。

##### 6.2.1 工厂模式
工厂模式：用函数来封装以特定接口创建对象的细节。但没有解决对象识别的问题（即怎样道一个对象的类型）。

##### 6.2.2 构造函数模式
构造函数模式与工厂模式不同之处：
- 没有显式地创建对象；
- 直接将属性和方法赋给了 this 对象；
- 没有 return 语句。
 
注意：**构造函数始终都应该以一个大写字母开头**，而非构造函数则应该以一个小写字母开头。

要创建 Person 的新实例，必须使用**new**操作符。新实例都有一个constructor（构造函数）属性，该属性指向构造函数。

将构造函数当作函数：构造函数也可以当做普通函数使用。例：

    // 当作构造函数使用
    var person = new Person("Nicholas", 29, "Software Engineer");
    person.sayName(); //"Nicholas"
    
    // 作为普通函数调用
    Person("Greg", 27, "Doctor"); // 添加到 window
    window.sayName(); //"Greg"
    
    // 在另一个对象的作用域中调用
    var o = new Object();
    Person.call(o, "Kristen", 25, "Nurse");
    o.sayName(); //"Kristen"

构造函数的问题：每个方法都要在每个实例上重新创建一遍。在函数内部定义一个新的函数的话，相当于每次使用构造函数都会创建一次完成同样任务的Function实例。然而将函数定义转移到构造函数外部，也只能被某个对象调用。并且，如果对象需要定义很多方法，就要定义很多个全局函数，这样构造函数的封装度被进一步降低，就没有意义了。

##### 6.2.3 原型模式
prototype（原型）属性：一个指向对象的**指针**，这个对象的用途是包含**可以由特定类型的所有实例共享的属性和方法**。

使用原型对象优点：可以让所有对象实例共享它所包含的属性和方法（不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中）。例：

    function Person(){
    }//空函数
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
    alert(this.name);
    };
    /*
    *在这里，person1和person2访问的都是同一组属性和同一个 sayName() 函数。
    */
    var person1 = new Person();
    person1.sayName();    //"Nicholas"
    var person2 = new Person();
    person2.sayName();   //"Nicholas"
    alert(person1.sayName == person2.sayName);    //true

如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。例：

    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
    alert(this.name);
    };
    var person1 = new Person();
    person1.name = "Greg";
    alert(person1.name); //"Greg" ——来自实例

**添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。**即使将这个属性设置为 null ，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用**delete操作符**则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

hasOwnProperty()：检测一个属性是存在于实例中，还是存在于原型中。存在于对象实例中时返回 true 。

###### 原型与in操作符
in操作符使用方式：(1)单独使用;(2)在for-in循环中使用。

单独使用：in操作符会在**通过对象能够访问给定属性**时返回true，无论该属性存在于实例中还是原型中。例：

    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
    alert(this.name);
    };
    var person1 = new Person();
    alert("name" in person1);    //true

同时使用 hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中：

    function hasPrototypeProperty(object, name){
        return !object.hasOwnProperty(name) && (name in object);
    }

在for-in循环中使用：返回所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]] 标记为 false 的属性）的实例属性也会在for-in循环中返回。

要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的**Object.keys()**方法。这个方法接收一个对象作为参数，返回一个包含所有**可枚举属性**的字符串数组。如果你想要得到所有实例属性，无论它是否可枚举，则可以使用**Object.getOwnPropertyNames()**方法。例：

    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
    alert(this.name);
    };
    var keys = Object.keys(Person.prototype);
    alert(keys);    //"name,age,job,sayName"
    var p1 = new Person();
    p1.name = "Rob";
    p1.age = 31;
    var p1keys = Object.keys(p1);
    alert(p1keys);    //"name,age"
     
    var keys = Object.getOwnPropertyNames(Person.prototype);
    alert(keys); //"constructor,name,age,job,sayName"

###### 更简单的原型语法
为减少不必要的输入，也为了从视觉上更好地封装原型的功能，可以用一个包含所有属性和方法的**对象字面量**来重写整个原型对象。例：

    function Person(){
    }
    Person.prototype = {
        /*
        *constructor : Person
        */
        name : "Nicholas",
        age : 29,
        job: "Software Engineer",
        sayName : function () {
            alert(this.name);
        }
    };

**注意**：constructor属性不再指向Person了。变成了新对象的constructor属性（指向Object构造函数）。若要使constructor属性重新指向Person，可在对象字面量里加上“**constructor : Person**”。以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为 true（原生是不可枚举的）。可以使用以下语句设置[[Enumerable]]特性：

    Object.defineProperty(Person.prototype, "constructor", {
        enumerable: false,
        value: Person
    });
    
###### 原型的动态性
体现在我们对原型对象所做的**任何修改**都能够**立即**从实例上反映出来。

**注意**：调用构造函数时会为实例添加一个**指向最初原型**的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系（实例中的指针仅指向原型，而不指向构造函数）。


###### 原生对象的原型
通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以**定义新方法**。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。例：

    String.prototype.startsWith = function (text) {
        return this.indexOf(text) == 0;
    };  //给基本包装类型String 添加了一个名为startsWith()的方法。
    var msg = "Hello world!";
    alert(msg.startsWith("Hello")); //true（当前环境中的所有字符串都可以调用）

原型对象的问题：实例一般都是要有属于自己的全部属性的。无法做到完全共享。这样原型中的引用类型可能会比较鸡肋。

##### 6.2.4 组合使用构造函数模式和原型模式
优点：**构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性**。这样每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。例：

    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = ["Shelby", "Court"];
    }  //构造函数模式用于定义实例属性
    Person.prototype = {
        constructor : Person,
        sayName : function(){
            alert(this.name);
        }
    }  //原型模式用于定义方法和共享的属性
    var person1 = new Person("Nicholas", 29, "Software Engineer");
    var person2 = new Person("Greg", 27, "Doctor");
    person1.friends.push("Van");
    alert(person1.friends); //"Shelby,Count,Van"
    alert(person2.friends); //"Shelby,Count"
    alert(person1.friends === person2.friends); //false
    alert(person1.sayName === person2.sayName); //true
    
#### 6.3 继承
##### 6.3.1 原型链
**基本思想**：利用原型让一个引用类型继承另一个引用类型的属性和方法（原型对象等于另一个类型的实例）。

**基本模式**：

    function SuperType(){
        this.property = true;
    }
    SuperType.prototype.getSuperValue = function(){
        return this.property;
    };
    function SubType(){
        this.subproperty = false;
    }
    //继承了 SuperType
    SubType.prototype = new SuperType();
    SubType.prototype.getSubValue = function (){
        return this.subproperty;
    };
    var instance = new SubType();
    alert(instance.getSuperValue()); //true
    
**最终结果**：instance指向SubType的原型，SubType的原型又指向SuperType的原型。调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype ；3）搜索 SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到**原型链末端**才会停下来。

**默认原型**：**所有引用类型默认都继承了Object**，而这个继承也是通过原型链实现的。**所有函数的默认原型都是Object的实例**，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。

**确定原型和实例的关系**：

1）使用instanceof操作符：用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。例：

    /*
    *在上面例子中，instance是Object、SuperType或SubType中任何一个类型的实例。故：
    */
    alert(instance instanceof Object); //true
    alert(instance instanceof SuperType); //true
    alert(instance instanceof SubType); //true
    
2）使用isPrototypeOf()方法：要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true。例：

    alert(Object.prototype.isPrototypeOf(instance)); //true
    alert(SuperType.prototype.isPrototypeOf(instance)); //true
    alert(SubType.prototype.isPrototypeOf(instance)); //true

原型添加方法的代码一定要放在替换原型的语句之后：

    function SuperType(){
        this.property = true;
    }
    SuperType.prototype.getSuperValue = function(){
        return this.property;
    };
    function SubType(){
        this.subproperty = false;
    }
    //继承了 SuperType
    SubType.prototype = new SuperType();  //实例替换原型
    /*
    *必须在用 SuperType 的实例替换原型之后，再定义这两个方法。
    */
    // 添加新方法
    SubType.prototype.getSubValue = function (){
        return this.subproperty;
    };
    // 重写超类型中的方法
    SubType.prototype.getSuperValue = function (){
        return false;
    };
    var instance = new SubType();
    alert(instance.getSuperValue()); //false
    
**注意**：不能使用对象字面量创建原型方法，这样做会重写原型链。

**原型链存在的问题**：包含引用类型值的原型属性会被所有实例共享，我们在实例中对引用属性的修改就无法体现出来。而在原型链中，原先的实例属性就变成了现在的原型属性了。这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。

##### 6.3.2 借用构造函数
基本思想：在子类型构造函数的内部调用超类型构造函数。

通过使用apply()和call()方法可以在（将来）新创建的对象上执行构造函数。例：

    function SuperType(){
        this.colors = ["red", "blue", "green"];
    }
    function SubType(){
        // 继承了 SuperType
        SuperType.call(this);  //SuperType.apply(this)也是可以的
    }
    var instance1 = new SubType();
    instance1.colors.push("black");
    alert(instance1.colors); //"red,blue,green,black"
    var instance2 = new SubType();
    alert(instance2.colors); //"red,blue,green"

相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数**传递参数**。例：

    function SuperType(name){
        this.name = name;
    }
    function SubType(){
        //继承了 SuperType，同时还传递了参数
        SuperType.call(this, "Nicholas");
        //实例属性
        this.age = 29;
    }
    var instance = new SubType();
    alert(instance.name); //"Nicholas";
    alert(instance.age); //29
    
**借用构造函数的问题**：方法都在构造函数中定义，因此无法做到函数复用。在超类型的原型中定义的方法，对子类型而言也是不可见的。这样的话所有类型都只能使用构造函数模式。

##### 6.3.3 组合继承
组合继承指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。例：

    function SuperType(name){
        this.name = name;
        this.colors = ["red", "blue", "green"];
    }
    SuperType.prototype.sayName = function(){
        alert(this.name);
    };
    function SubType(name, age){
        //继承属性
        SuperType.call(this, name);
        this.age = age;
    }
    //继承方法
    SubType.prototype = new SuperType();
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = function(){
        alert(this.age);
    };
     
    var instance1 = new SubType("Nicholas", 29);
    instance1.colors.push("black");
    alert(instance1.colors); //"red,blue,green,black"
    instance1.sayName(); //"Nicholas";
    instance1.sayAge(); //29
     
    var instance2 = new SubType("Greg", 27);
    alert(instance2.colors); //"red,blue,green"
    instance2.sayName(); //"Greg";
    instance2.sayAge(); //27

##### 6.3.4 原型式继承
借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。例：

    var person = {
        name: "Nicholas",
        friends: ["Shelby", "Court", "Van"]
    };
     
    var anotherPerson = object(person);
    anotherPerson.name = "Greg";
    anotherPerson.friends.push("Rob");
     
    var yetAnotherPerson = object(person);
    yetAnotherPerson.name = "Linda";
    yetAnotherPerson.friends.push("Barbie");
    alert(person.friends);    //"Shelby,Court,Van,Rob,Barbie"

上面例子意味着person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson 共享。实际上，这就相当于又创建了person对象的两个副本。

**Object.create()方法**：在传入一个参数的情况下，Object.create()与object()方法的行为相同。第二个参数与 Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例：

    var person = {
        name: "Nicholas",
        friends: ["Shelby", "Court", "Van"]
    };
    var anotherPerson = Object.create(person, {
        name: {
            value: "Greg"
        }
    });
    alert(anotherPerson.name); //"Greg"  //覆盖原型中的name
    
##### 6.3.5 寄生式继承
寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。例：

    function createAnother(original){
        var clone = object(original); //通过调用函数创建一个新对象
        clone.sayHi = function(){ //以某种方式来增强这个对象
            alert("hi");
        };
        return clone; //返回这个对象
    }
    var person = {
        name: "Nicholas",
        friends: ["Shelby", "Court", "Van"]
    };
    var anotherPerson = createAnother(person);
    anotherPerson.sayHi(); //"hi"
    /*
    *这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法。
    */
    
##### 6.3.6 寄生组合式继承
组合继承存在的问题：无论什么情况下，都会调用**两次**超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。例：

    function SuperType(name){
        this.name = name;
        this.colors = ["red", "blue", "green"];
    }
    SuperType.prototype.sayName = function(){
        alert(this.name);
    };
    function SubType(name, age){
        SuperType.call(this,name);//第二次调用SuperType()又在新对象上创建了实例属性name和colors。
        this.age = age;
    }
    SubType.prototype = new SuperType(); // 第一次调用 SuperType()，得到两个属性： name和colors。
     
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = function(){
    alert(this.age);
    };
    
寄生组合式继承基本思路：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型
的原型。基本模式如下：

    function inheritPrototype(subType, superType){
        var prototype = object(superType.prototype); //创建对象
        prototype.constructor = subType; //增强对象
        subType.prototype = prototype; //指定对象
    }
    
这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的 constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样就可以替换前面例子中为子类型原型赋值的语句了。


### 《红宝书》 第七章-函数表达式
**定义函数的方式有两种：一种是函数声明，另一种是函数表达式。**

关于函数声明，它的一个重要特征就是**函数声明提升**，意思是在执行代码之前会先读取函数声明。意味着**可以把函数声明放在调用它的语句后面**。语法如下：

    function functionName(arg0, arg1, arg2) {
        //函数体
    }
    
第二种创建函数的方式是使用函数表达式，函数表达式与其他表达式一样，在使用前必须先赋值。常见语法形式如下：

    var functionName = function(arg0, arg1, arg2){
        //函数体
    };

函数作为其他函数的**值**返回。

#### 7.1 递归
**递归函数是在一个函数通过名字调用自身的情况下构成的**，如下所示：

    function factorial(num){
        if (num <= 1){
            return 1;
        } else {
            return num * factorial(num-1);
        }
    }
     
    /*
    *下面的代码可能导致出错:
    */
    var anotherFactorial = factorial;
    factorial = null;
    alert(anotherFactorial(4)); //出错
    
上面例子中，调用anotherFactorial()时，由于必须执行factorial()，而factorial在第一次被调用之后已经不再是函数。所以会导致错误。使用 arguments.callee可以解决这个问题：

    function factorial(num){
        if (num <= 1){
            return 1;
        } else {
            return num * arguments.callee(num-1);
        }
    }

arguments.callee是一个指向**正在执行**的函数的指针。

在严格模式下，可以使用**命名函数表达式**来达成相同的结果。例：

    var factorial = (function f(num){
        if (num <= 1){
            return 1;
        } else {
            return num * f(num-1);
        }
    });

以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字 f仍然有效，所以递归调用照样能正确完成。

#### 7.2 闭包
**闭包是指有权访问另一个函数作用域中的变量的函数**。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

##### 7.2.1 闭包与变量
闭包只能取得包含函数中任何变量的**最后一个值**。例：

    function createFunctions(){
        var result = new Array();
        for (var i=0; i < 10; i++){
            result[i] = function(){
                return i;
            };
        }
        return result;
    }

因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，所以在每个函数内部 i 的值都是10，而不是值为0~9的函数数组。我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示：

    function createFunctions(){
        var result = new Array();
        for (var i=0; i < 10; i++){
            result[i] = function(num){
                return function(){
                    return num;
                };
            }(i);
        }
        return result;
    }
    
在这个版本中，我们定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。由于函数参数是**按值传递**的，所以就会将变量i的当前值复制给数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。

##### 7.2.2 关于 this 对象
匿名函数的执行环境具有**全局性**，因此其this对象通常指向window。

把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象。例：

    var name = "The Window";
    var object = {
        name : "My Object",
        getNameFunc : function(){
            var that = this; //定义了闭包之后，闭包也可以访问这个变量
            return function(){
                return that.name;
            };
        }
    };
    alert(object.getNameFunc()()); //"My Object"
    
##### 7.2.3 内存泄漏
如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例：

    function assignHandler(){
        var element = document.getElementById("someElement");
        element.onclick = function(){
            alert(element.id);
        };
    } //由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少 element 的引用数。
    
通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用，再把element变量设置为**null**（原因：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用）。可以顺利地减少其引用数，确保正常回收其占用的内存。例：

    function assignHandler(){
        var element = document.getElementById("someElement");
        var id = element.id;
        element.onclick = function(){
            alert(id);
        };
        element = null;
    }

##### 7.3 模仿块级作用域
**JavaScript没有块级作用域的概念**。

    function outputNumbers(count){
        for (var i=0; i < count; i++){
            alert(i);
        }
        alert(i); //计数
    }
    
在上面例子中，变量 i是定义在ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它（而不是像Java、C++等语言，只在for循环的语句块中有定义，一旦循环结束，i就被销毁）。

匿名函数可以用来模仿块级作用域并避免这个问题。用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示：

    (function(){
        //这里是块级作用域
    })();

实际上这是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。

函数声明后面不能跟圆括号。函数表达式的后面可以跟圆括号。

无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。例：

    function outputNumbers(count){
        (function () {
            for (var i=0; i < count; i++){
                alert(i);
            }
        })(); //在 for循环外部插入了一个私有作用域,在匿名函数中定义的任何变量，会在执行结束时被销毁。
         
        alert(i); //导致一个错误！
    }
    
#### 7.4 私有变量
任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。**私有变量包括函数的参数、局部变量和在函数内部定义的其他函数**。

我们把有权访问私有变量和私有函数的公有方法称为特权方。有两种在对象上创建特权方法的方式。第一种是在**构造函数中定义特权方法**，基本模式如下：

    function MyObject(){
        //私有变量和私有函数
        var privateVariable = 10;
        function privateFunction(){
            return false;
        }
        //特权方法
        this.publicMethod = function (){
            privateVariable++;
            return privateFunction();
        };
    }
    
对这个例子而言，变量 privateVariable和函数privateFunction()只能通过特权方法publicMethod() 来访问。

构造函数中定义特权方法的缺点：**必须使用构造函数模式来达到这个目的**。这样针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。

##### 7.4.1 静态私有变量
通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下所示：

    (function(){
        //私有变量和私有函数
        var privateVariable = 10;
        function privateFunction(){
            return false;
        }
        //构造函数
        MyObject = function(){
        };
        //公有/特权方法
        MyObject.prototype.publicMethod = function(){
            privateVariable++;
            return privateFunction();
        };
    })();
    
公有方法是在原型上定义的，这一点体现了典型的原型模式。由于没有在声明MyObject时使用var关键字，所以MyObject就成了一个全局变量，能够在私有作用域之外被访问到。

以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。

##### 7.4.2 模块模式
**模块模式（module pattern）是为单例创建私有变量和特权方法**。单例（singleton）指的就是只有一个实例的对象。JavaScript 是以对象字面量的方式来创建单例对象的：

    var singleton = {
        name : value,
        method : function () {
            //这里是方法的代码
        }
    };
    
模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：

    var singleton = function(){
        //私有变量和私有函数
        var privateVariable = 10;
        function privateFunction(){
            return false;
        }
        //特权/公有方法和属性
        return {
            publicProperty: true,
            publicMethod : function(){
                privateVariable++;
                return privateFunction();
            }
        };
    }();
    
这个模块模式使用了一个返回对象的匿名函数。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：

    var application = function(){
        //私有变量和函数
        var components = new Array();
        //初始化
        components.push(new BaseComponent());
        //公共
        return {
            getComponentCount : function(){
                return components.length;
            },
            registerComponent : function(component){
                if (typeof component == "object"){
                    components.push(component);
                }
            }
        };
    }();

简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。

##### 7.4.3 增强的模块模式
增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。例：

    var singleton = function(){
        //私有变量和私有函数
        var privateVariable = 10;
        function privateFunction(){
            return false;
        }
        //创建对象
        var object = new CustomType();
        //添加特权/公有属性和方法
        object.publicProperty = true;
        object.publicMethod = function(){
            privateVariable++;
            return privateFunction();
        };
        //返回这个对象
        return object;
    }();

如果前面演示模块模式的例子中的application对象必须是BaseComponent的实例，那么就可以使用以下代码：

    var application = function(){
        //私有变量和函数
        var components = new Array();
        //初始化
        components.push(new BaseComponent());
        //创建 application 的一个局部副本
        var app = new BaseComponent();
        //公共接口
        app.getComponentCount = function(){
            return components.length;
        };
        app.registerComponent = function(component){
            if (typeof component == "object"){
                components.push(component);
            }
        };
        //返回这个副本
        return app;
    }();

### 《红宝书》 第十三章-事件
JavaScript与HTML之间的交互是通过**事件**实现的。

#### 13.1 事件流
事件流描述的是从页面中**接收事件的顺序**。

##### 13.1.1 事件冒泡
**IE的事件流叫做事件冒泡**，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面HTML页面为例：

    <!DOCTYPE html>
    <html>
    <head>
        <title>Event Bubbling Example</title>
    </head>
    <body>
        <div id="myDiv">Click Me</div>
    </body>
    </html>

如果你单击了页面中的 < div> 元素，那么这个 click 事件会按照如下顺序传播：(1)< div>
(2) < body> (3) < html>(4)document。可以看出：事件沿DOM树向上传播，在每一级节点上都会发生，直至传播到document对象。

##### 13.1.2 事件捕获
事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于**在事件到达预定目标之前捕获它**。

以前面 HTML页面作为事件捕获的演示例子，那么单击< div>元素就会以下列顺序触发click 事件：(1) document (2) < html> (3) < body> (4) < div>

##### 13.1.3 DOM事件流
事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。

#### 13.2 事件处理程序
事件就是用户或浏览器自身执行的某种动作。而响应某个事件的**函数**就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以 "**on**" 开头。

##### 13.2.1 HTML事件处理程序
代码例子：

    <input type="button" value="Click Me" onclick="alert('Clicked')" />

注意：不能在其中使用未经转义的HTML语法字符。

在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方或外部文件定义的脚本。因为事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。例：

    <script type="text/javascript">
        function showMessage(){
            alert("Hello world!");
        }
    </script>
    <input type="button" value="Click Me" onclick="showMessage()" />

上面例子的函数中有一个局部变量event，也就是事件对象。

动态创建的函数也可以扩展作用域。使用with()可以像访问局部变量一样访问document及该元素本身的成员。使用方法如下：

    function(){
        with(document){
            with(this){
            //元素属性值
            }
        }
    }
    
为了防止HTML元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件：将HTML事件处理程序封装在一个 try-catch 块中。例：

    <input type="button" value="Click Me" onclick="try{showMessage();}catch(ex){}">
    /*
    *这样，如果在 showMessage()函数有定义之前单击了按钮，用户将不会看到JavaScript错误，因为在浏览器有机会处理错误之前，错误就被捕获了。
    */
    
缺点：HTML与 avaScript代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML代码和JavaScript代码。

##### 13.2.2 DOM0 级事件处理程序
通过 JavaScript 指定事件处理程序的传统方式，就是**将一个函数赋值给一个事件处理程序属性**。这种方法首先必须取得一个要操作的对象的引用。例：

    var btn = document.getElementById("myBtn"); //通过文档对象取得了一个按钮的引用
    btn.onclick = function(){
        alert("Clicked");
    };
    
可以删除通过 DOM0 级方法指定的事件处理程序，只要像下面这样将事件处理程序属性的值设
置为 null 即可：
    
    btn.onclick = null; //删除事件处理程序
    
##### 3.2.3 DOM2 级事件处理程序
“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：**addEventListener()** 和 **removeEventListener()**。接受3个参数：**要处理的事件名、作为事件处理程序的函数和一个布尔值**。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。例：

    var btn = document.getElementById("myBtn");
    btn.addEventListener("click", function(){
        alert(this.id);
    }, false);

通过 addEventListener()添加的事件处理程序**只能**使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。例：

    /*
    *移除上面例子中的事件
    */
    btn.removeEventListener("click", function(){ // 没有用！
        alert(this.id);
    }, false);
    
实际上第二个参数与传入addEventListener()中的那一个是完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同，故应如下修改：
    

    var btn = document.getElementById("myBtn");
    var handler = function(){
        alert(this.id);
    };
    btn.addEventListener("click", handler, false);
    // 这里省略了其他代码
    btn.removeEventListener("click", handler, false); // 有效！

##### 13.2.4 IE事件处理程序
IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。通过attachEvent()添加的事件处理程序都会被添加到**冒泡阶段**。例：

    var btn = document.getElementById("myBtn");
    btn.attachEvent("onclick", function(){
        alert("Clicked");
    });

在IE中使用attachEvent()与使用DOM0级方法的主要区别：在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent()方法的情况下，事件处理程序会在**全局作用域**中运行，因此this等于window。

attachEvent()方法也可以用来为一个元素添加多个事件处理程序。与addEventListener()不同之处在于：attachEvent()方法的事件处理程序**不是以添加它们的顺序执行，而是以相反的顺序被触发** 。

使用 attachEvent() 添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。与DOM方法一样，这也意味着添加的匿名函数将不能被移除。

##### 13.2.5 跨浏览器的事件处理程序
目的：为了以**跨浏览器**的方式处理事件。

要创建的方法是 addHandler()，它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫EventUtil的对象。addHandler()方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。与 addHandler()对应的方法是removeHandler() ，它也接受相同的参数。用法如下：

    var EventUtil = {
        addHandler: function(element, type, handler){
            if (element.addEventListener){
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent){
                element.attachEvent("on" + type, handler);
            } else {
                element["on" + type] = handler;
            }
        },
        removeHandler: function(element, type, handler){
            if (element.removeEventListener){
                element.removeEventListener(type, handler, false);
            } else if (element.detachEvent){
                element.detachEvent("on" + type, handler);
            } else {
                element["on" + type] = null;
            }
        }
    };
     
    var btn = document.getElementById("myBtn");
    var handler = function(){
        alert("Clicked");
    };
    EventUtil.addHandler(btn, "click", handler);
    // 这里省略了其他代码
    EventUtil.removeHandler(btn, "click", handler);
    
#### 13.3 事件对象
在触发DOM上的某个事件时，会产生一个事件对象**event**，这个对象中包含着所有与事件有关的信息。

##### 13.3.1 DOM中的事件对象
兼容DOM的浏览器会将一个event对象传入到事件处理程序中（无论是DOM0级还是DOM2级）。

在通过 HTML 特性指定事件处理程序时，变量event中保存着event对象。

event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。（所有事件都有的成员见书P373）

**在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。**如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值。如果事件处理程序存在于按钮的父节点中，那么这些值是不相同的。

在需要通过一个函数**处理多个事件时**，可以使用type属性。例：

    var btn = document.getElementById("myBtn");
    var handler = function(event){
        switch(event.type){
            case "click":
                alert("Clicked");
                break;
            case "mouseover":
                event.target.style.backgroundColor = "red";
                break;
            case "mouseout":
                event.target.style.backgroundColor = "";
                break;
        }
    };
    btn.onclick = handler;
    btn.onmouseover = handler;
    btn.onmouseout = handler;
    
要阻止特定事件的默认行为，可以使用 preventDefault() 方法。例：

    var link = document.getElementById("myLink");
    link.onclick = function(event){
        event.preventDefault();
    };
    
上面例子中，链接的默认行为就是在被单击时会导航到其href特性指定的URL。如果你想阻止链接导航这一默认行为，那么通过链接的onclick 事件处理程序可以取消它。

stopPropagation()方法用于立即停止事件在DOM层次中的传播，即**取消进一步的事件捕获或冒泡**。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在 document.body 上面的事件处理程序，如下所示：

    var btn = document.getElementById("myBtn");
    btn.onclick = function(event){
        alert("Clicked");
        event.stopPropagation();
    };
    document.body.onclick = function(event){
        alert("Body clicked");
    };  //不会触发
    
事件对象的eventPhase属性，可以用来确定事件**当前正位于事件流的哪个阶段**。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则 eventPhase等于2 ；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。

##### 13.3.2 IE中的事件对象
要访问IE中的event对象有几种不同的方式，在使用DOM0级方法添加事件处理程序时，event对象作为**window对象的一个属性**存在。例：

    var btn = document.getElementById("myBtn");
    btn.onclick = function(){
        var event = window.event; //通过 window.event取得了event对象
        alert(event.type); //"click"
    };

如果事件处理程序是使用attachEvent()添加的，那么就会有一个event对象**作为参数被传入事件处理程序函数**中。

IE的event对象同样也包含与创建它的事件相关的**属性和方法**。（所有事件对象都会包含的属性和方法见书P377）

returnValue 属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为。语法如下：

    window.event.returnValue = false;
    
cancelBubble属性与DOM中的stopPropagation()方法作用相同，都是用来停止事件冒泡的（由于IE**不支持事件捕获**，因而只能取消事件冒泡）。将cancelBubble设置为true，就可阻止事件冒泡。语法如下：

    window.event.cancelBubble = true;
    
##### 13.3.3 跨浏览器的事件对象
虽然DOM和IE中的 event对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。如下：

    var EventUtil = {
        addHandler: function(element, type, handler){
            //省略的代码
        },
        getEvent: function(event){
            return event ? event : window.event;
        },
        getTarget: function(event){
            return event.target || event.srcElement;
        },
        preventDefault: function(event){
            if (event.preventDefault){
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        removeHandler: function(element, type, handler){
            //省略的代码
        },
        stopPropagation: function(event){
            if (event.stopPropagation){
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        }
    };
    
在获得其他方法之前，都必须首先使用EventUtil.getEvent()取得了event对象。

#### 13.4 事件类型
“**DOM3级事件**”规定了以下几类事件：
- UI（User Interface，用户界面）事件：当用户与页面上的元素交互时触发；
- 焦点事件：当元素获得或失去焦点时触发；
- 鼠标事件：当用户通过鼠标在页面上执行操作时触发；
- 滚轮事件：当使用鼠标滚轮（或类似设备）时触发；
- 文本事件：当在文档中输入文本时触发；
- 键盘事件：当用户通过键盘在页面上执行操作时触发；
- 合成事件：当为 IME（Input Method Editor，输入法编辑器）输入字符时触发；
- 变动（mutation）事件：当底层 DOM 结构发生变化时触发。

##### 13.4.1 UI事件
###### 1.load事件
JavaScript 中最常用的一个事件就是load。当页面**完全加载**后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发window上面的load事件。有两种定义 onload 事件处理程序的方式。第一种方式是使用如下所示的JavaScript代码(更推荐）：

    /*
    *这个传入的event对象中不包含有关这个事件的任何附加信息
    */
    EventUtil.addHandler(window, "load", function(event){
        alert("Loaded!");
    });

第二种指定 onload 事件处理程序的方式是为<body>元素添加一个onload特性，如下面的例子所示：

    <body onload="alert('Loaded!')">
       //内容
    </body>
    
图像上面也可以触发load事件，因此，可以在HTML中为任何图像指定onload事件处理程序。

###### 2. unload 事件
与load事件对应的是unload事件。这个事件在文档被**完全卸载**后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况是**清除引用**，以避免内存泄漏。两种定义 onload 事件处理程序的方式与load相似。

###### 3. resize 事件
当浏览器窗口被调整到一个**新的高度或宽度**时，就会触发resize事件。这个事件在window（窗口）上面触发，因此可以通过JavaScript（推荐）或者<body>元素中的**onresize**特性来指定事件处理程序。

注意：IE、Safari、Chrome和Opera会随着浏览器窗口变化不断重复触发resize事件（精度为1像素）。所以不要在这个事件的处理程序中加入大计算量的代码，因为这些代码有可能被频繁执行，从而导致浏览器反应明显变慢。

###### 4. scroll 事件
scroll事件是在window对象上发生的。在标准模式下，所有浏览器都会通过 < html>元素来 反映这一变化（除了Safari）；在混杂模式下，可以通过<body>元素的**scrollLeft（水平滚动位置）** 和 **scrollTop（垂直滚动位置）** 来监控到这一变化。

**scroll事件也会在文档被滚动期间重复被触发**，所以有必要尽量保持事件处理程序的代码简单。

##### 13.4.2 焦点事件
焦点事件会在页面元素**获得或失去**焦点时触发。有以下4个焦点事件（2个弃用）：

- blur：在元素**失去焦点**时触发。这个事件不会冒泡；所有浏览器都支持它。

- focus ：在元素**获得焦点**时触发。这个事件不会冒泡；所有浏览器都支持它。

- focusin ：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它**冒泡**。支持这个事件的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome。

- focusout ：在元素失去焦点时触发。这个事件是 HTML事件blur的通用版本。支持这个事件
的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome。

##### 13.4.3 鼠标与滚轮事件
DOM3 级事件中定义了9个鼠标事件，如下：
- click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。


- dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。
 
- mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。

- mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在**光标移动到后代元素上不会触发**。

- mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在**光标移动到后代元素上不会触发**。

- mousemove：当鼠标指针在元素内部移动时**重复地触发**。不能通过键盘触发这个事件。

- mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。

- mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。

- mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。

###### 1. 客户区坐标位置
clientX：鼠标指针在**视口**中的水平坐标。

clientY：鼠标指针在**视口**中的垂直坐标。

###### 2. 页面坐标位置
pageX：鼠标指针在距离**页面**左边中的水平距离。

pageY：鼠标指针在距离**页面**顶部中的垂直距离。

注意：**在页面没有滚动的情况下**，pageX和pageY的值与clientX和clientY的值相等。

###### 3. 屏幕坐标位置
screenX：鼠标指针相对于**整个电脑屏幕**的左边的距离。

screenY：鼠标指针相对于**整个电脑屏幕**的上边的距离。

###### 4. 修改键
修改键就是Shift、Ctrl、Alt和Meta（在Windows键盘中是Windows键，在苹果机中是Cmd键），它们经常被用来**修改鼠标事件的行为**。

4个属性表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。包含的都是布尔值。**如果相应的键被按下了，则值为true，否则值为false**。、

###### 5. 相关元素
对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素；对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。

DOM通过event对象的relatedTarget属性提供了相关元素的信息。**这个属性只对于mouseover和mouseout事件才包含值**；对于其他事件，这个属性的值是null。

在mouseover事件触发时，IE的fromElement属性中保存了相关元素；在mouseout事件触发时，IE的toElement属性中保存着相关元素。

跨浏览器取得相关元素的方法：

    var EventUtil = {
        //省略了其他代码
        getRelatedTarget: function(event){
            if (event.relatedTarget){
                return event.relatedTarget;
            } else if (event.toElement){
                 return event.toElement;
            } else if (event.fromElement){
                return event.fromElement;
            } else {
                return null;
            }
        },
        //省略了其他代码
    };
    
###### 6. 鼠标按钮
对于mousedown和mouseup事件来说，则在其event对象存在一个**button属性**，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮（鼠标左键），1表示中间的鼠标按钮（鼠标滚轮按钮），2 表示次鼠标按钮（鼠标右键）。

###### 7. 更多的事件信息
- offsetX ：光标相对于**目标元素边界**的 x 坐标。
- offsetY ：光标相对于**目标元素边界**的 y 坐标。

###### 8. 鼠标滚轮事件
用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发mousewheel事件。这个事件可以在**任何元素**上面触发，最终会冒泡到document或window对象。

与mousewheel事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的**wheelDelta属性**。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。

###### 9. 触摸设备
在面向iPhone和iPod中的Safari开发时，要记住以下几点：

- 不支持dblclick事件。（双击只会使页面放大且无法改变）；
- mousemove事件也会触发mouseover和mouseout事件；
- 两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件；
- 轻击可单击元素会触发mousemove事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生mousedown、mouseup和click事件。

##### 13.4.4 键盘与文本事件
用户在使用键盘时会触发键盘事件。有3个键盘事件，如下：
- keydown：当用户按下键盘上的任意键时触发，如果按住不放的话，会重复触发此事件。
- keypress：当用户按下键盘上的字符键时触发，如果按住不放的话，会重复触发此事件。
- keyup：当用户释放键盘上的键时触发。

在文本插入文本框之前会触发textInput事件（只有这一个文本事件）。

###### 1. 键码
在发生keydown和keyup事件时，event对象的keyCode属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，**keyCode属性的值与ASCII码中对应小写字母或数字的编码相同**（与shift键状态无关）。非字符键的键码见书P398。

###### 2. 字符编码
charCode属性只有在发生keypress事件时才包含值，而且这个值是按下的那个键所代表字符的 **ASCII编码**（此时keyCode等于0或者所按键的键码）。

跨浏览器的方式取得字符编码需检测charCode属性是否可用，不可用则使用keyCode。语法如下：

    var EventUtil = {
        //省略的代码
        getCharCode: function(event){
            if (typeof event.charCode == "number"){
                return event.charCode;
            } else {
                return event.keyCode;
            }
        },
        //省略的代码
    };
    
######  3. DOM3级变化
DOM3级事件中的键盘事件，不再包含charCode属性，而是包含两个新属性：key和char。在按下某个字符键时，key的值就是相应的文本字符；在按下非字符键时，key的值是相应键的名。而char属性在按下字符键时的行为与key相同，但在按下非字符键时值为null。

###### 4. textInput 事件
 textInput事件与keypress事件的区别：（1）任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput事件。（2）textInput事件只会在用户按下能输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发。
 
#####  13.4.5 复合事件
复合事件用于处理IME（输入法编译器）的输入序列，让用户可以输入在物理键盘上找不到的字符。复合事件见书P402。

##### 13.4.6 变动事件
DOM2级的变动事件能在DOM中的某一部分发生变化时给出提示。DOM2级定义了如下变动事件：

- DOMSubtreeModified ：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发
后都会触发。


- DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。

- DOMNodeRemoved ：在节点从其父节点中被移除时触发。

- DOMNodeInsertedIntoDocument ：在一个节点被直接插入文档或通过子树间接插入文档之后
触发。这个事件在DOMNodeInserted之后触发。

- DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移
除之前触发。这个事件在DOMNodeRemoved之后触发。

- DOMAttrModified ：在特性被修改之后触发。

- DOMCharacterDataModified ：在文本节点的值发生变化时触发。

##### 13.4.7 HTML5 事件
###### 1. contextmenu 事件
用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。

###### 2. beforeunload 事件
这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载，询问用户是否真的要关闭页面，还是希望继续留下来。

###### 3. DOMContentLoaded 事件
 window的load事件会在页面中的一切都加载完毕时触发，而DOMContentLoaded事件则在形成完整的DOM树之后就会触发（不理会图像、JavaScript文件、CSS文件或其他资源是否已经下载完毕）。这也就意味着用户能够尽早地与页面进行交互。
 
对于不支持DOMContentLoaded的浏览器，我们建议在页面加载期间设置一个时间为0毫秒的超
时调用，如下所示：

    setTimeout(function(){
        //在此添加事件处理程序
    }, 0);  //为了确保这个方法有效，必须将其作为页面中的第一个超时调用,且不一定效果显著。
    
###### 4. readystatechange 事件
#### 



### 《红宝书》 第二十章-JSON
JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示**结构化数据**。

**JSON是一种（轻量级）数据（交换）格式，不是一种编程语言**。虽然具有相同的语法形式，但JSON并不从属于JavaScript。不是只有JavaScript才使用JSON。很多编程语言都有针对JSON的解析器和序列化器。

#### 20.1 语法
JSON语法可以表示以下三种类型的值：
- 简单值：使用与JavaScript相同的语法，可以在 JSON 中表示字符串、数值、布尔值和null （不支持JavaScript中的特殊值undefined）。
- 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。
- 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。

**JSON不支持变量、函数或对象实例**。

##### 20.1.1 简单值
简单值是**最简单的**JSON数据形式。通常只是整个数据结构的一部分。

注意：JSON字符串必须使用**双引号**。

##### 20.1.2 对象
JSON对象要用“**{}**”保存。

JSON中的对象与JavaScript字面量差异：

JavaScript中的对象字面量：

    var person = {
        name: "Nicholas",
        age: 29
    };
    
JSON表示上述对象的方式：

    {
        "name": "Nicholas",
        "age": 29
    }

从上面的对比中可以看出三点不同：（1）JSON没有声明变量（因为JSON没有变量这个概念）；（2）没有末尾的分号（因为不是JavaScript语句，可以不遵循JavaScript的语法格式）；（3）**对象的属性必须加双引号**（JavaScript中的对象字面量也可以加双引号，不影响数据）。

**JSON对象属性的值也可以是复杂类型值，所以也可以在对象中嵌入对象**。属于不同对象的属性名可以相同。但是同一个对象不能出现同名属性。

##### 20.1.3 数组
数组字面量用“**[]**”保存。

JavaScript中的数组字面量：

    var values = [25, "hi", true];
    
JSON表示上述数组的方式：

    [25, "hi", true]

同样可以看出JSON数组没有变量和分号。

把数组和对象结合可以构成更复杂的数据集合。例：

    {
        "title": "Professional Ajax",
        "authors": [
            "Nicholas C. Zakas",
            "Jeremy McPeak",
            "Joe Fawcett"
        ],
        edition: 2,
        year: 2008
    }
    
#### 20.2 解析与序列化
JSON的优势：可以把JSON数据结构解析为有用的JavaScript对象。

##### 20.2.1 JSON对象
JSON 对象有两个方法：stringify()和parse()。分别用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript值。例：

    var book = {
        title: "Professional JavaScript",
        authors: [
            "Nicholas C. Zakas"
        ],
        edition: 3,
        year: 2011
    };
     
    /*
    * 把一个JavaScript对象序列化为一个JSON字符串,然后将它保存在变量jsonText中。
    */
    var jsonText = JSON.stringify(book);

保存在 jsonText 中的字符串如下所示：

    {"title":"Professional JavaScript","authors":["Nicholas C. Zakas"],"edition":3,"year":2011}

将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值。如下：

    var bookCopy = JSON.parse(jsonText);
    
如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误。

##### 20.2.2 序列化选项
除了要序列化的JavaScript对象外，JSON.stringify()还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。这两个参数可以单独使用或组合使用。

###### 1. 过滤结果
（1）如果过滤器参数是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性。例：

    /*
    *JavaScript对象见20.2.1
    */
    var jsonText = JSON.stringify(book, ["title", "edition"]);

在返回的结果字符串中，就只会包含这两个属性：

    {"title":"Professional JavaScript","edition":3}
    
（2）如果过滤器参数是函数，行为会稍有不同。传入的函数接收两个参数，属性名和属性值。属性名只能是字符串，而在值并非键值对结构的值时，键名可以是空字符串。为了改变序列化对象的结果，函数返回的值就是相应键的值（注意：如果函数返回了undefined，那么相应的属性会被忽略）。例：

    var jsonText = JSON.stringify(book, function(key, value){
        switch(key){
            case "authors":
                return value.join(",")
            case "year":
                return 5000;
            case "edition":
                return undefined; //设置为undefined，则删除该属性
            default:
                return value; //返回传入的值，以便其他值都能正常出现在结果中。
        }
    });

序列化后的JSON字符串如下所示：

    {"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000}
    
###### 2. 字符串缩进
JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。参数是数值是表示每个级别缩进的空格数（最大缩进空格数为10，所有大于10的值都会自动转换为10）。例：

    var jsonText = JSON.stringify(book, null, 2);

保存在jsonText中的字符串如下所示：

    {
      "title": "Professional JavaScript",
      "authors": [
          "Nicholas C. Zakas"
      ],
      "edition": 3,
      "year": 2011
    }

如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符（缩进字符串最长不能超过10个字符长。如果字符串长度超过了10个，结果中将只出现前10个字符。
例：

    var jsonText = JSON.stringify(book, null, "--");

jsonText 中的字符串将变成如下所示：

    {
      --"title": "Professional JavaScript",
      --"authors": [
      ----"Nicholas C. Zakas"
      --],
      --"edition": 3,
      --"year": 2011
    }

###### 3. toJSON() 方法
给对象定义toJSON()方法，返回其自身的JSON数据格式。

    var book = {
        "title": "Professional JavaScript",
        "authors": [
            "Nicholas C. Zakas"
        ],
        edition: 3,
        year: 2011,
        toJSON: function(){
            return this.title;  //返回图书的书名（以字符串形式）
        }
    };
     
    var jsonText = JSON.stringify(book);  

序列化顺序：

(1) 如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则返回对象本身。

(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。

(3) 对第(2)步返回的每个值进行相应的序列化。

(4) 如果提供了第三个参数，执行相应的格式化。


##### 20.2.3 解析选项

